<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>学习</title>
  </head>
  <body>
    <canvas id="c2d" class="c2d" width="1000" height="500"></canvas>
    <script type="module">
      import * as THREE from './file/three.js-dev/build/three.module.js'
      import { OrbitControls } from './file/three.js-dev/examples/jsm/controls/OrbitControls.js'

      const canvas = document.querySelector('#c2d')
      // 渲染器
      const renderer = new THREE.WebGLRenderer({ canvas })

      const fov = 40 // 视野范围
      const aspect = 2 // 相机默认值 画布的宽高比
      const near = 0.1 // 近平面
      const far = 10000 // 远平面
      // 透视投影相机
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
      camera.position.set(0, 0, 3)
      camera.lookAt(0, 0, 0)
      // 控制相机
      const controls = new OrbitControls(camera, canvas)
      controls.update()

      // 场景
      const scene = new THREE.Scene()

      const vertexShader = `
      varying vec2 vUv;
      varying vec3 vPosition;

      void main(){
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          vUv = uv;
          vPosition = position;
      }
      `

      // const fragmentShader = `
      // uniform float uTime;
      // uniform vec2 uMouse;
      // uniform vec2 uResolution;

      // varying vec2 vUv;
      // varying vec3 vPosition;

      // void main(){
      //     vec3 color = vec3(vUv.x,vUv.y,1.);
      //     gl_FragColor = vec4(color,1.);
      // }
      // `
      const fragmentShader = `
      varying vec2 vUv;

      float sdBox(vec3 p,vec3 b)
      {
          vec3 q=abs(p)-b;
          return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);
      }

      float sdf(vec3 p){
          float box=sdBox(p,vec3(.3));
          return box;
      }

      vec3 background(vec2 uv){
          float dist=length(uv-vec2(.5));
          vec3 bg=mix(vec3(.3),vec3(.0),dist);
          return bg;
      }

      void main(){
          vec3 bg=background(vUv);
          vec3 color=bg;
          gl_FragColor=vec4(color,1.);
      }
      `

      const geometry = new THREE.PlaneGeometry(2, 2, 100, 100)
      const shaderMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.DoubleSide,
        uniforms: {
          uTime: {
            value: 0
          },
          uMouse: {
            value: new THREE.Vector2(0, 0)
          },
          uResolution: {
            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
          }
        }
      })

      const mesh = new THREE.Mesh(geometry, shaderMaterial)

      mesh.position.copy(new THREE.Vector3(0, 0, 0))

      scene.add(mesh)

      // 渲染
      function render() {
        renderer.render(scene, camera)
        requestAnimationFrame(render)
      }
      requestAnimationFrame(render)
    </script>
  </body>
</html>
