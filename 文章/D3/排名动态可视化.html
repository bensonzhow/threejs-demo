<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>学习</title>
  </head>
  <style type="text/css">
    text.title {
      font-size: 2em;
      font-weight: 500;
    }
    text.subTitle {
      font-weight: 500;
      fill: #777777;
    }
    text.label {
      font-weight: bold;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <body>
    <div class="d3Chart"></div>
  </body>
  <script type="text/javascript">
    const margin = { top: 80, right: 65, bottom: 5, left: 20 }

    const width = 1200
    const height = 600

    const svg = d3.select('.d3Chart').append('svg').attr('width', width).attr('height', height)
    // 图
    const chart = svg.append('g').attr('transform', `translate(${margin.top}, ${margin.left})`)

    // 展示条数
    const top_n = 20
    // 间距
    const barPadding = (height - margin.top - margin.bottom) / (top_n * 5)

    let title = chart
      .append('text')
      .attr('class', 'title')
      .attr('y', 30)
      .attr('x', width / 2)
      .text('BrandRank')

    let subTitle = chart
      .append('text')
      .attr('y', 30)
      .attr('x', width - margin.right - 160)
      .attr('class', 'subTitle')
      .text('Brand value  ,  $m')

    let year = 2000
    const tickDuration = 100 // 执行间隔

    let xScale = d3
      .scaleLinear()
      .range([margin.left, width - margin.right])
      .nice()

    let yScale = d3
      .scaleLinear()
      .domain([top_n, 0])
      .range([height - margin.bottom, margin.top])

    let xAxis = d3
      .axisTop(xScale)
      .ticks(width > 500 ? 5 : 2)
      .tickSize(-(height - margin.top - margin.bottom))
    // .tickFormat((d) => d3.format(',')(d))

    /**
     * 绘制图形
     */
    function render_init(yearSlice) {
      xScale.domain([0, d3.max(yearSlice, (d) => d.value) + 10000])

      svg.append('g').attr('class', 'xAxis').call(xAxis).attr('transform', `translate(${margin.left},${margin.top})`)

      //首次join rect
      svg
        .selectAll('rect.bar')
        .data(yearSlice, (d) => d.name)
        .enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', xScale(0) + margin.left + 2)
        .attr('width', (d) => xScale(d.value) - xScale(0))
        .attr('y', (d) => yScale(d.rank))
        .attr('height', yScale(1) - yScale(0) - barPadding)
        .attr('fill', (d) => d.color)

      //首次join text,品牌名
      svg
        .selectAll('text.label')
        .data(yearSlice, (d) => name)
        .enter()
        .append('text')
        .attr('class', 'label')
        .attr('x', (d) => xScale(d.value) - 8)
        .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2)
        .attr('text-anchor', 'end')
        .text((d) => d.name)

      //首次join text,数值
      svg
        .selectAll('text.valueLabel')
        .data(yearSlice, (d) => d.name)
        .enter()
        .append('text')
        .attr('class', 'valueLabel')
        .attr('x', (d) => xScale(d.value) + 19)
        .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2)
        .text((d) => d3.format(',.0f')(d.lastValue))

      //年份
      yearText = svg
        .append('text')
        .attr('class', 'yearText')
        .attr('x', width - margin.right + 60)
        .attr('y', height - 25)
        .attr('font-size', '2em')
        .style('font-weight', 'bold')
        .style('fill', '#2eb0c5d9')
        .style('text-anchor', 'end')
        .html(~~year)
    }

    // d3.csv() 获取逗号分隔值（CSV）文件
    d3.csv('./file/brand_values.csv').then((data) => {
      console.log('🚀 ~ file: 排名动态可视化.html ~ line 23 ~ d3.csv ~ data', data)
      //数据预处理
      data.forEach((d) => {
        d.lastValue = +d.lastValue
        d.value = isNaN(d.value) ? 0 : +d.value
        d.year = +d.year
        d.rank = +d.rank
        d.color = d3.hsl(Math.random() * 360, 0.75, 0.75, 0.8)
      })
      console.log(data)
      let yearSlice = data
        .filter((d) => d.year == year && !isNaN(d.value))
        .sort((a, b) => b.value - a.value)
        .slice(0, top_n)
      //此时索引就是排名了
      yearSlice.forEach((d, i) => (d.rank = i))

      render_init(yearSlice)

      let ticker = d3.interval((e) => {
        // 重新切分数据
        yearSlice = data
          .filter((d) => d.year == year && !isNaN(d.value))
          .sort((a, b) => b.value - a.value)
          .slice(0, top_n)
        yearSlice.forEach((d, i) => {
          d.rank = i
        })

        xScale.domain([0, d3.max(yearSlice, (d) => d.value) + 10000])
        //x轴随着图元的值修改
        svg.select('.xAxis').transition().duration(tickDuration).ease(d3.easeLinear).call(xAxis)

        //第一步：获取update部分
        let bars = svg.selectAll('.bar').data(yearSlice, (d) => d.name)

        //enter,将尚未存在top12中的数据加入进来
        //注意，transition前的y是在svg之外的，这样才会做成从下面往上浮现的效果
        bars
          .enter()
          .append('rect')
          .attr('class', 'bar')
          .attr('x', xScale(0) + margin.left + 2)
          .attr('width', (d) => xScale(d.value) - xScale(0))
          .attr('y', (d) => yScale(top_n + 1) + 20)
          .attr('height', yScale(1) - yScale(0) - barPadding)
          .attr('fill', (d) => d.color)
        // .transition()
        // .duration(tickDuration)
        // .ease(d3.easeLinear)
        // .attr('y', (d) => yScale(d.rank))

        bars
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr('width', (d) => xScale(d.value) - xScale(0))
          .attr('y', (d) => yScale(d.rank))

        //最后一步exit()
        bars
          .exit()
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr('y', (d) => yScale(top_n + 1) + 5)
          .attr('width', 0)
          .remove()

        //labels与bars相同
        let labels = svg.selectAll('.label').data(yearSlice, (d) => d.name)

        labels
          .enter()
          .append('text')
          .attr('class', 'label')
          .attr('x', (d) => xScale(d.value) - 8)
          .attr('y', (d) => yScale(top_n + 1) + 20)
          .attr('text-anchor', 'end')
          .text((d) => d.name)
        // .transition()
        // .duration(tickDuration)
        // .ease(d3.easeLinear)
        // .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2 + 1)

        labels
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr('x', (d) => xScale(d.value) - 8)
          .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2 + 1)

        labels
          .exit()
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          // .attr('x', d => xScale(d.value) -8 )
          .attr('y', (d) => yScale(top_n + 1) + 20)
          .remove()

        let valueLabels = svg.selectAll('.valueLabel').data(yearSlice, (d) => d.name)

        valueLabels
          .enter()
          .append('text')
          .attr('class', 'valueLabel')
          .attr('x', (d) => xScale(d.value) + 19)
          .attr('y', (d) => yScale(top_n) + 20)
          .text((d) => d3.format(',.0f')(d.lastValue))
        //enter进来的时候用lastvalue，后面update的时候再慢慢增加至value
        // .transition()
        // .duration(tickDuration)
        // .ease(d3.easeLinear)
        // .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2)

        valueLabels
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr('x', (d) => xScale(d.value) + 19)
          .attr('y', (d) => yScale(d.rank) + (yScale(1) - yScale(0)) / 2)
          .tween('textTween', function (d) {
            //做出在两个value间跳动的效果
            let i = d3.interpolateRound(d.lastValue, d.value)
            return function (t) {
              this.textContent = d3.format(',')(i(t))
            }
          })

        valueLabels
          .exit()
          .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr('x', (d) => xScale(d.value) + 19)
          .attr('y', (d) => yScale(top_n + 1) + 20)
          .remove()

        yearText.html(~~year)
        //~~year：等于向上取整，2018.1 取反等于 -2019， 再次取反等于2019

        if (year == 2018) {
          ticker.stop()
        }
        // 格式 YYYY.MM
        year = d3.format('.1f')(+year + 0.1)
      }, tickDuration)
    })
  </script>
</html>
